## 编写一个方法 求一个字符串的字节长度

假设：一个英文字符占用一个字节，一个中文字符占用两个字节
```
 function GetBytes(str){

        var len = str.length;

        var bytes = len;

        for(var i=0; i<len; i++){

            if (str.charCodeAt(i) > 255) bytes++;

        }

        return bytes;

    }

alert(GetBytes("你好,as"));
```

## js对象的深度克隆
```
function clone(obj) {
    let buf; 
    if (obj instanceof Array) {
        buf = [];
        for (let i in Array) {
            buf[i] = clone(obj[i]);
        }
        return buf;
    } else if (obj instanceof Object) {
        buf = {};
        for (let i in obj) {
            buf[i] = clone(obj[i]);
        }
        return buf;
    } else {
        return obj;
    }
}
```
## 数组去重
```
Array.prototype.unique = function() {
    var n = [];
    for (let i of this) {
        if (n.indexOf(i) !== -1) {
            n.push(i);
        }
    }
}
```

```
function fun(...arg) {
    var s = new Set(arg);
    return [...s];
}

function fun(...arg) {
    return Array.from(new Set(arg));
}
console.log(fun(1, 2, 3, 2));
```

## arguments, 类数组对象，转化为数组
arguments对象还有一个callee属性，该属性是一个指针，指向拥有这个arguments对象的函数。
>在严格模式下，
像上面那样把arguments[1]设置为10，num2的值仍然不变。重写arguments的值会导致语法错误
不能使用argumengs.callee

```
var array = Array.prototype.slice.call(arguments);

var array = Array.from(arguments);
```

## 大数相加
```
function add (srcA, srcB) {
    var i, temp, tempA, tempB, len, lenA, lenB, carry = 0;
    var res = [],
        arrA = [],
        arrB = [],
        cloneArr = [];
    arrA = (srcA + "").split("");
    arrB = (srcB + "").split("");
    arrA.reverse();
    arrB.reverse();
    lenA = arrA.length;
    lenB = arrB.length;
    len = lenA > lenB ? lenB : lenA;
    for (i = 0; i < len; i++) {
        tempA = parseInt(arrA[i], 10);
        tempB = parseInt(arrB[i], 10);
        temp = tempA + tempB + carry;
        if (temp > 9) {
            res.push(temp - 10);
            carry = 1;
        } else {
            res.push(temp);
            carry = 0;
        }
    }
    cloneArr = lenA > lenB ? arrA : arrB;
    for (; i < cloneArr.length; i++) {
        tempA = parseInt(cloneArr[i], 10);
        temp = tempA + carry;
        if (temp > 9) {
            res.push(temp - 10);
            carry = 1;
        } else {
            res.push(temp);
            carry = 0;
        }
    }
    return (res.reverse()).join('');
};
```

## 封装链表，insert,delete
http://www.cnblogs.com/webARM/p/5425190.html
```
//数据部分（data）、指向前一个的指针（preNode）、指向后一个的指针（nextNode）
function CreateLinkNode(data, pre, next){
    this.data = data;
    this.preNode = pre;
    if(this.preNode){
        pre.nextNode = this;
    }
    this.nextNode = next;
}
```